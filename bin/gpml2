#!/usr/bin/env bash

# see https://stackoverflow.com/a/246128/5354298
get_script_dir() { echo "$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"; }
SCRIPT_DIR=$(get_script_dir)
LATEST_GPML_VERSION="2013a"

cleanup() {
  echo "done" > /dev/null
}

# Based on http://linuxcommand.org/lc3_wss0140.php
# and https://codeinthehole.com/tips/bash-error-reporting/
PROGNAME=$(basename $0)
error_exit() {
#	----------------------------------------------------------------
#	Function for exit due to fatal program error
#		Accepts 1 argument:
#			string containing descriptive error message
#	----------------------------------------------------------------


  #echo "${PROGNAME}: ${1:-"Unknown Error"}" 1>&2
  if [ ! "$1" ]; then
    echo "${PROGNAME}: Unknown Error" 1>&2
    read line file <<<$(caller)
    echo "An error occurred in line $line of file $file:" 1>&2
    sed "${line}q;d" "$file" 1>&2
  else
    echo "${PROGNAME}: $1" 1>&2
  fi

  cleanup
  exit 1
}

trap error_exit ERR
trap cleanup EXIT INT QUIT TERM

TOP_OPTS=$(getopt -o hv: --long help,version:,id:,pathway-version: \
             -n 'gpml2' -- "$@")
if [ $? != 0 ] ; then error_exit "Error: Failed to parse options." ; fi
# NOTE: keep the quotes
eval set -- "$TOP_OPTS"

HELP=false
VERSION=false
ID=
PATHWAY_VERSION=
while true; do
  case "$1" in
    -h | --help ) HELP=true; shift ;;
    -v | --version ) VERSION=true; shift ;;
    --id ) ID="$2"; shift 2 ;;
    --pathway-version ) PATHWAY_VERSION="$2"; shift 2 ;;
    -- ) shift; break ;;
    * ) break ;;
  esac
done

if [ $VERSION == true ]; then
  # TODO: this is not a real version
  echo "1.0.0"
  exit 0
elif [ $HELP == true ]; then
  echo 'usage: gpml2 --version'
  echo '       gpml2 --help'
  echo '       gpml2 [--id] [--pathway-version] <input> [output] [scale=100]'
  echo '           If no output specified, all supported formats generated, as siblings of input.'
  echo '           "scale" is only valid for conversions to PNG format.'
  echo ' '
  echo 'examples on example data WP1243_69897.gpml:'
  exit 0
fi

path_in="$1"
path_out="$2"

if [ ! -f "$path_in" ]; then
  error_exit "Missing file '"$path_in"'"
fi

dir_in=$(dirname "$path_in")
base_in=$(basename -- "$path_in")
ext_in="${base_in##*.}"
stub_in="${base_in%.*}"

if [ -z "$ID" ] || [ -z "$PATHWAY_VERSION" ]; then
  wp_id="${stub_in%_*}"
  pathway_version_candidate="${stub_in##*_}"
  if [ -n "$wp_id" ] && [ -n "$pathway_version_candidate" ]; then
    ID="http://identifiers.org/wikipathways/$wp_id"
    PATHWAY_VERSION="$pathway_version_candidate"
  fi
fi

# if an output path isn't specified, we'll just convert to all the outputs.
if [ -z "$path_out" ]; then
  for format in json owl pdf png pwf react.svg svg txt; do
    out_f="$dir_in/$stub_in.$format"
    #"$SCRIPT_DIR/gpml2" --id "$ID" --pathway-version "$PATHWAY_VERSION" "$path_in" "$out_f";

    #"$SCRIPT_DIR/gpml2" --id "$ID" --pathway-version "$PATHWAY_VERSION" "$path_in" "$out_f" || exit 1;

    if ! "$SCRIPT_DIR/gpml2" --id "$ID" --pathway-version "$PATHWAY_VERSION" "$path_in" "$out_f" ; then
      echo "  Failed to complete the following conversion:" 1>&2;
      echo "    $SCRIPT_DIR/gpml2 \\" 1>&2;
      echo "    --id $ID \\" 1>&2;
      echo "    --pathway-version $PATHWAY_VERSION \\" 1>&2;
      echo "    $path_in \\" 1>&2;
      echo "    $path_in" 1>&2;
      exit 1;
    fi

    #"$SCRIPT_DIR/gpml2" --id "$ID" --pathway-version "$PATHWAY_VERSION" "$path_in" "$out_f" || \
    #  (echo "Error: $SCRIPT_DIR/gpml2 --id $ID --pathway-version $PATHWAY_VERSION $path_in $out_f" 1>&2; \
	#exit 1)

    #"$SCRIPT_DIR/gpml2" --id "$ID" --pathway-version "$PATHWAY_VERSION" "$path_in" "$out_f" || \
    # (echo "Error: $SCRIPT_DIR/gpml2 --id $ID --pathway-version $PATHWAY_VERSION $path_in $out_f"; \
	#exit 1)

    #"$SCRIPT_DIR/gpml2" --id "$ID" --pathway-version "$PATHWAY_VERSION" "$path_in" "$out_f" || \
    #  error_exit "Error: $SCRIPT_DIR/gpml2 --id $ID --pathway-version $PATHWAY_VERSION $path_in $out_f" ;
  done
  exit 0
fi

dir_out=$(dirname "$path_out")
base_out=$(basename -- "$path_out")
ext_out="${base_out##*.}"
stub_out="${base_out%.*}"

gpml_f="$dir_in/$stub_in.gpml"

# TODO: which is better?
#xmlstarlet val "$f";
#if [ $? -eq 0 ]; then ... fi
is_valid=$((xmlstarlet val "$gpml_f" | grep ' valid') || echo '');
if [ ! "$is_valid" ]; then
  error_exit "Error: Invalid GPML for $gpml_f"
fi

ns=$(xmlstarlet sel -t -v "//namespace::*[name()='']" "$gpml_f" | head -n 1)
gpml_version="${ns##*/}"
if [ -z "$gpml_version" ]; then
  error_exit "Error: GPML namespace missing. Expecting '$LATEST_GPML_VERSION'"
elif [ "$gpml_version" != "$LATEST_GPML_VERSION" ]; then
  old_f="$dir_in/$stub_in.$gpml_version.gpml"
  mv "$gpml_f" "$old_f"
  pathvisio convert "$old_f" "$gpml_f"
fi

if [[ "$ext_out" =~ ^(gpml|owl|pdf|pwf|txt)$ ]]; then
  pathvisio convert "$path_in" "$path_out"
elif [[ "$ext_out" =~ ^(png)$ ]]; then
  # TODO: look at using --scale as an option (instead of an argument), for both pathvisio and gpml2.
  # TODO: move the setting of a default value for scale into pathvisio instead of here.
  # Setting default value of 100 if none is set
  scale=${3:-100}
  pathvisio convert "$path_in" "$path_out" "$scale"
  # Use interlacing? See https://github.com/PathVisio/pathvisio/issues/78
  # It's probably not worthwhile. If we did it, we would need to install imagemagick and then run this:
  # mv "$path_out" "$path_out.noninterlaced.png"
  # convert -interlace PNG "$path_out.noninterlaced.png" "$path_out"
elif [[ "$ext_out" =~ ^(json|jsonld)$ ]]; then
  organism=$(xmlstarlet sel -N gpml="http://pathvisio.org/GPML/$LATEST_GPML_VERSION" -t -v '/gpml:Pathway/@Organism' "$path_in" || echo '')
  # TODO: bridgedbjs fails when no xrefs are present. Update bridgedbjs to do this check:
  xref_identifiers=$((xmlstarlet sel -N gpml="http://pathvisio.org/GPML/$LATEST_GPML_VERSION" -t -v '/gpml:Pathway/gpml:DataNode/gpml:Xref/@ID' "$path_in" | sed '/^$/d') || echo '')

  if [ -z "$organism" ] || [ -z "$xref_identifiers" ]; then
    gpml2pvjson --id "$ID" --pathway-version "$PATHWAY_VERSION" < "$path_in" > "$path_out"
  else
    gpml2pvjson --id "$ID" --pathway-version "$PATHWAY_VERSION" < "$path_in" | \
      bridgedb xrefs -f json \
        -i '.entitiesById[].type' "$organism" '.entitiesById[].xrefDataSource' '.entitiesById[].xrefIdentifier' \
        ensembl hgnc.symbol ncbigene uniprot hmdb chebi wikidata \
      > "$path_out"
  fi

elif [[ "$ext_out" =~ ^(svg)$ ]]; then
  bare_stub_out="${base_out%%.*}"
  all_exts_out="${base_out#*.}"
  second_ext_out="${all_exts_out%.*}"

  json_f="$dir_out/$bare_stub_out.json"
  "$SCRIPT_DIR/gpml2" --id "$ID" --pathway-version "$PATHWAY_VERSION" "$path_in" "$json_f"

#  if [[ "$base_out" =~ (react.svg)$ ]]; then
#    pvjs --react < "$json_f" > "$path_out"
#  else
  pvjs --react < "$json_f" > "$path_out"

  # TODO: make the stand-alone SVGs work for upload to WM Commons:
  # https://www.mediawiki.org/wiki/Manual:Coding_conventions/SVG
  # https://commons.wikimedia.org/wiki/Help:SVG
  # https://commons.wikimedia.org/wiki/Commons:Commons_SVG_Checker?withJS=MediaWiki:CommonsSvgChecker.js
  # http://validator.w3.org/#validate_by_upload+with_options


  # WM says: "the recommended image height is around 400–600 pixels. When a
  #           user views the full size image, a width of 600–800 pixels gives
  #           them a good close-up view"
  # https://commons.wikimedia.org/wiki/Help:SVG#Frequently_asked_questions

  standalone_f="$dir_out/$stub_out.standalone.svg"
  pvjs < "$json_f" | \
    xmlstarlet ed -N svg='http://www.w3.org/2000/svg' \
                  -i '/svg:svg' --type attr -n width -v '800px' \
                  -i '/svg:svg' --type attr -n height -v '600px' \
    > "$standalone_f"

  edge_count=$(cat "$standalone_f" | xmlstarlet sel -N svg='http://www.w3.org/2000/svg' -t -v 'count(/svg:svg/svg:g/svg:g[contains(@typeof,'Edge')])')

  for i in $(seq $edge_count); do
    xmlstarlet ed -L -N svg='http://www.w3.org/2000/svg' \
		  -m "/svg:svg/svg:g/svg:g[contains(@typeof,'Edge')][$i]/svg:g/svg:path" \
		     "/svg:svg/svg:g/svg:g[contains(@typeof,'Edge')][$i]" \
		  "$standalone_f";
  done

  for attr in "filter" "fill" "fill-opacity" "stroke" "stroke-dasharray" "stroke-width"; do
    xmlstarlet ed -L -N svg='http://www.w3.org/2000/svg' \
                  -i "/svg:svg/svg:g/svg:g[contains(@typeof,'Edge')]" -t attr -n "$attr" -v "REPLACE_ME" \
		  -u "/svg:svg/svg:g/svg:g[contains(@typeof,'Edge')]/@$attr" \
		  -x "string(../svg:g/@$attr)" \
		  "$standalone_f"
  done

  for attr in "color" "fill" "fill-opacity" "stroke" "stroke-dasharray" "stroke-width"; do
    xmlstarlet ed -L -N svg='http://www.w3.org/2000/svg' \
                  -i "/svg:svg/svg:g/svg:g[contains(@typeof,'Edge')]/svg:path" -t attr -n "$attr" -v "REPLACE_ME" \
		  -u "/svg:svg/svg:g/svg:g[contains(@typeof,'Edge')]/svg:path/@$attr" \
		  -x "string(../../svg:g/@$attr)" \
		  "$standalone_f"
  done

  xmlstarlet ed -L -N svg='http://www.w3.org/2000/svg' \
                -d "/svg:svg/svg:g/svg:g[contains(@typeof,'Edge')]/svg:g" \
		-d "/svg:svg/svg:g/svg:g[contains(@typeof,'Edge')]/svg:path/@style" \
		"$standalone_f"

  # Which of the following is correct?
  # To make the SVG file independent of Arial, change all occurrences of
  #   font-family: Arial to font-family: 'Liberation Sans', Arial, sans-serif
  #   https://commons.wikimedia.org/wiki/Help:SVG#fallback
  # vs.
  # Phab:T64987, Phab:T184369, Gnome #95; font-family="'font name'"
  #   (internally quoted font family name) does not work
  #   (File:Mathematical_implication_diagram-alt.svg, File:T184369.svg)
  #   https://commons.wikimedia.org/wiki/Commons:Commons_SVG_Checker?withJS=MediaWiki:CommonsSvgChecker.js
  xmlstarlet ed -L -N svg='http://www.w3.org/2000/svg' \
		-u "//*[contains(@font-family,'Arial')]/@font-family" \
		-v "Liberation Sans, sans-serif" \
		 "$standalone_f"
  xmlstarlet ed -L -N svg='http://www.w3.org/2000/svg' \
		-u "//*[contains(@font-family,'arial')]/@font-family" \
		-v "Liberation Sans, sans-serif" \
		"$standalone_f"

  xmlstarlet ed -L -N svg='http://www.w3.org/2000/svg' \
                -i "/svg:svg/svg:defs/svg:g/svg:svg/svg:defs/svg:marker/svg:path[not(@fill)]" -t attr -n "fill" -v "REPLACE_ME" \
		-u "/svg:svg/svg:defs/svg:g/svg:svg/svg:defs/svg:marker/svg:path[@fill='REPLACE_ME']/@fill" \
		-v "currentColor" \
		"$standalone_f"

# see https://www.reddit.com/r/bash/comments/8ucx8a/can_you_use_bash_scripting_to_calculate_the/
invert_color() {
  color="$1"

  case "$color" in
        none)
            echo 'none'
            ;;
         
        transparent)
            echo 'transparent'
            ;;
         
        black)
            echo 'white'
            ;;
         
        white)
            echo 'black'
            ;;
         
        *)
  	    printf -v color '#%06X' $((0x${color#\#} ^ 0xFFFFFF))
	    echo "$color"
  esac
}

invert_filter() {
  from_color=$(echo "$1" | sed 's/^url[(]#kaavio\(.*\)to\(.*\)filter[)]$/\1/')
  to_color=$(echo "$1" | sed 's/^url[(]#kaavio\(.*\)to\(.*\)filter[)]$/\2/')
  inverted_from_color=$(invert_color $from_color)
  #inverted_to_color=$(invert_color $to_color)
  echo "url(#kaavio"$inverted_from_color"to"$to_color"filter)"
}

  xmlstarlet ed -L -N svg='http://www.w3.org/2000/svg' \
		-u "/svg:svg/@color" \
  		-v "white" \
		-u "/svg:svg/svg:g/@color" \
  		-v "white" \
		-d "/svg:svg/svg:style" \
                -d "/svg:svg/svg:g//*/svg:text/@overflow" \
                -d "/svg:svg/svg:g//*/svg:text/@dominant-baseline" \
                -d "/svg:svg/svg:g//*/svg:text/@clip-path" \
                -d "/svg:svg/svg:g//svg:defs" \
		"$standalone_f";

  # TODO: push the text down based on font size. Add some value to the existing transform="translate(40,10)"
  # so maybe for a font size of 10, we'd add 5 to get transform="translate(40,15)"
  el_count=$(xmlstarlet sel -N svg='http://www.w3.org/2000/svg' -t -v "count(/svg:svg/svg:g//svg:text)" "$standalone_f")
  for i in $(seq $el_count); do
    font_size=$(xmlstarlet sel -N svg='http://www.w3.org/2000/svg' -t -v "(/svg:svg/svg:g//svg:text)[$i]/@font-size" "$standalone_f" | sed 's/^\([0-9.]*\)px$/\1/g');
  from_color=$(echo "$1" | sed 's/^url[(]#kaavio\(.*\)to\(.*\)filter[)]$/\1/')
    font_size=${font_size:-5}
    x_translation=$(xmlstarlet sel -N svg='http://www.w3.org/2000/svg' -t -v "(/svg:svg/svg:g//svg:text)[$i]/@transform" "$standalone_f" | sed 's/^translate[(]\([0-9.]*\),\([0-9.]*\)[)]$/\1/g');
    y_translation=$(xmlstarlet sel -N svg='http://www.w3.org/2000/svg' -t -v "(/svg:svg/svg:g//svg:text)[$i]/@transform" "$standalone_f" | sed 's/^translate[(]\([0-9.]*\),\([0-9.]*\)[)]$/\2/g');
    updated_y_translation=$(echo "$font_size / 3 + $y_translation" | bc)
    xmlstarlet ed -L -N svg='http://www.w3.org/2000/svg' \
		  -u "(/svg:svg/svg:g//svg:text)[$i]/@transform" \
		  -v "translate($x_translation,$updated_y_translation)" \
		  "$standalone_f";
  done

#  # TODO: State? Burr? Group?
#  for x in "DataNode" "CellularComponent" "Shape" "Label" "Group"; do
#    xmlstarlet ed -L -N svg='http://www.w3.org/2000/svg' \
#		-u "/svg:svg/svg:g//svg:g[contains(@typeof,'$x')]/svg:rect[contains(@class,'Icon')]/@class" \
#  		-x "concat(.,' ','$x','-Icon')" \
#		"$standalone_f";
#
#    xmlstarlet ed -L -N svg='http://www.w3.org/2000/svg' \
#		-u "/svg:svg/svg:g//svg:g[contains(@typeof,'$x')]/svg:use[contains(@class,'Icon')]/@class" \
#  		-x "concat(.,' ','$x','-Icon')" \
#		"$standalone_f";
#  done

  for attr in "color" "fill" "stroke"; do
    #echo "attr: $attr"
    el_count=$(xmlstarlet sel -N svg='http://www.w3.org/2000/svg' -t -v "count(/svg:svg/svg:g//*[@$attr])" "$standalone_f")
    #echo "el_count: $el_count";
    for i in $(seq $el_count); do
      #echo "i: $i of $el_count";
      color=$(xmlstarlet sel -N svg='http://www.w3.org/2000/svg' -t -v "(/svg:svg/svg:g//*[@$attr])[$i]/@$attr" "$standalone_f");
      #echo "color: $color";
      inverted_color=$(invert_color $color)
      #echo "inverted_color: $inverted_color"
      xmlstarlet ed -L -N svg='http://www.w3.org/2000/svg' \
  		    -u "(/svg:svg/svg:g//*[@$attr])[$i]/@$attr" \
		    -v $inverted_color \
		    "$standalone_f";

  		#-v "DUMMY" \

    done
  done

  el_count=$(xmlstarlet sel -N svg='http://www.w3.org/2000/svg' -t -v "count(/svg:svg/svg:g//*[@filter])" "$standalone_f")
  #echo "el_count: $el_count";
  for i in $(seq $el_count); do
    #echo "i: $i of $el_count";
    filter_value=$(xmlstarlet sel -N svg='http://www.w3.org/2000/svg' -t -v "(/svg:svg/svg:g//*[@filter])[$i]/@filter" "$standalone_f");
    #echo "color: $color";
    inverted_filter_value=$(invert_filter $filter_value)
    #echo "inverted_color: $inverted_color"
    xmlstarlet ed -L -N svg='http://www.w3.org/2000/svg' \
		  -u "(/svg:svg/svg:g//*[@filter])[$i]/@filter" \
		  -v $inverted_filter_value \
		  "$standalone_f";

  		#-v "DUMMY" \
  done

  # clip-path needed because rx and ry don't work in FF or Safari
  xmlstarlet ed -L -N svg='http://www.w3.org/2000/svg' \
                -i "/svg:svg/svg:g//svg:g[contains(@class,'DataNode')]/*[contains(@class,'Icon')]" -t attr -n "clip-path" -v "url(#ClipPathRoundedRectangle)" \
                -i "/svg:svg/svg:g//svg:g[contains(@class,'DataNode')]/*[contains(@class,'Icon')]" -t attr -n "rx" -v "15px" \
                -i "/svg:svg/svg:g//svg:g[contains(@class,'DataNode')]/*[contains(@class,'Icon')]" -t attr -n "ry" -v "15px" \
		-u "/svg:svg/svg:g//svg:g[contains(@class,'DataNode')]/*[contains(@class,'Icon')]/@stroke-width" \
		-v "0px" \
		-u "/svg:svg/svg:g//svg:g[contains(@class,'DataNode')]/*[contains(@class,'Text')]/@font-weight" \
		-v "bold" \
		-u "/svg:svg/svg:g//svg:g[contains(@class,'DataNode') and contains(@typeof, 'GeneProduct')]/*[contains(@class,'Icon')]/@fill" \
		-v "#f4d03f" \
		-u "/svg:svg/svg:g//svg:g[contains(@class,'DataNode') and contains(@typeof, 'GeneProduct')]/*[contains(@class,'Text')]/@fill" \
		-v "#333" \
		-u "/svg:svg/svg:g//svg:g[contains(@class,'DataNode') and contains(@typeof, 'Protein')]/*[contains(@class,'Icon')]/@fill" \
		-v "brown" \
		-u "/svg:svg/svg:g//svg:g[contains(@class,'DataNode') and contains(@typeof, 'Protein')]/*[contains(@class,'Text')]/@fill" \
		-v "#FEFEFE" \
		-u "/svg:svg/svg:g//svg:g[contains(@class,'DataNode') and contains(@typeof, 'Rna')]/*[contains(@class,'Icon')]/@fill" \
		-v "#9453A7" \
		-u "/svg:svg/svg:g//svg:g[contains(@class,'DataNode') and contains(@typeof, 'Rna')]/*[contains(@class,'Text')]/@fill" \
		-v "#ECF0F1" \
		-u "/svg:svg/svg:g//svg:g[contains(@class,'DataNode') and contains(@typeof, 'Pathway')]/*[contains(@class,'Icon')]/@fill" \
		-v "#75C95C" \
		-u "/svg:svg/svg:g//svg:g[contains(@class,'DataNode') and contains(@typeof, 'Pathway')]/*[contains(@class,'Text')]/@fill" \
		-v "#1C2833" \
		-u "/svg:svg/svg:g//svg:g[contains(@class,'DataNode') and contains(@typeof, 'Metabolite')]/*[contains(@class,'Icon')]/@fill" \
		-v "#0000EE" \
		-u "/svg:svg/svg:g//svg:g[contains(@class,'DataNode') and contains(@typeof, 'Metabolite')]/*[contains(@class,'Text')]/@fill" \
		-v "#FEFEFE" \
		-u "/svg:svg/svg:g//svg:g[contains(@class,'DataNode') and contains(@typeof, 'State')]/*[contains(@class,'Icon')]/@fill" \
		-v "#33BFFF" \
		"$standalone_f"

# filter="url(#kaavioblackto00cc66filter)"

#  dark_f="$dir_out/$stub_out.dark.svg"
#  pvjs --theme "dark" < "$json_f" | \
#    xmlstarlet ed -N svg='http://www.w3.org/2000/svg' -i '/svg:svg' --type attr -n width -v '800px' | \
#    xmlstarlet ed -N svg='http://www.w3.org/2000/svg' -i '/svg:svg' --type attr -n height -v '600px' \
#    > "$dark_f"
else
  error_exit "Invalid output extension: '$ext_out'"
fi

exit 0
